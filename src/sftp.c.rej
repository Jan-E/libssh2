--- src/sftp.c
+++ src/sftp.c
@@ -1869,76 +1864,16 @@ static ssize_t sftp_write(LIBSSH2_SFTP_HANDLE *handle, const char *buffer,
     ssize_t rc;
     struct sftp_pipeline_chunk *chunk;
     struct sftp_pipeline_chunk *next;
-    size_t acked = 0;
+    size_t acked = handle->u.file.acked;
     size_t org_count = count;
     size_t already;
 
-    switch(sftp->write_state) {
-    default:
-    case libssh2_NB_state_idle:
-
-        /* Number of bytes sent off that haven't been acked and therefore we
-           will get passed in here again.
-
-           Also, add up the number of bytes that actually already have been
-           acked but we haven't been able to return as such yet, so we will
-           get that data as well passed in here again.
-        */
-        already = (size_t) (handle->u.file.offset_sent - handle->u.file.offset)+
-            handle->u.file.acked;
-
-        if(count >= already) {
-            /* skip the part already made into packets */
-            buffer += already;
-            count -= already;
-        }
-        else
-            /* there is more data already fine than what we got in this call */
-            count = 0;
-
-        sftp->write_state = libssh2_NB_state_idle;
-        while(count) {
-            /* TODO: Possibly this should have some logic to prevent a very
-               very small fraction to be left but lets ignore that for now */
-            uint32_t size = MIN(MAX_SFTP_OUTGOING_SIZE, count);
-            uint32_t request_id;
-
-            /* 25 = packet_len(4) + packet_type(1) + request_id(4) +
-               handle_len(4) + offset(8) + count(4) */
-            packet_len = handle->handle_len + size + 25;
-
-            chunk = LIBSSH2_ALLOC(session, packet_len +
-                                  sizeof(struct sftp_pipeline_chunk));
-            if(!chunk)
-                return _libssh2_error(session, LIBSSH2_ERROR_ALLOC,
-                                      "malloc fail for FXP_WRITE");
-
-            chunk->len = size;
-            chunk->sent = 0;
-            chunk->lefttosend = packet_len;
-
-            s = chunk->packet;
-            _libssh2_store_u32(&s, packet_len - 4);
-
-            *(s++) = SSH_FXP_WRITE;
-            request_id = sftp->request_id++;
-            chunk->request_id = request_id;
-            _libssh2_store_u32(&s, request_id);
-            _libssh2_store_str(&s, handle->handle, handle->handle_len);
-            _libssh2_store_u64(&s, handle->u.file.offset_sent);
-            handle->u.file.offset_sent += size; /* advance offset at once */
-            _libssh2_store_str(&s, buffer, size);
-
-            /* add this new entry LAST in the list */
-            _libssh2_list_add(&handle->packet_list, &chunk->node);
-
-            buffer += size;
-            count -= size; /* deduct the size we used, as we might have
-                              to create more packets */
-        }
-
-        /* move through the WRITE packets that haven't been sent and send as many
-           as possible - remember that we don't block */
+    /* Number of bytes sent off that we haven't acked and therefore expect
+       to get passed in here again.
+    */
+    already = (size_t) (handle->u.file.offset_sent - handle->u.file.offset);
+    if(already > 0) {
+        /* There's a half-sent packet in queue; resume sending */
         chunk = _libssh2_list_first(&handle->packet_list);
 
         while(chunk) {
@@ -1954,95 +1888,141 @@ static ssize_t sftp_write(LIBSSH2_SFTP_HANDLE *handle, const char *buffer,
                 chunk->sent += rc;
 
                 if(chunk->lefttosend)
-                    /* data left to send, get out of loop */
-                    break;
+                    goto exit;
+
+                acked += chunk->len;
+                handle->u.file.offset += chunk->len;
             }
 
             /* move on to the next chunk with data to send */
             chunk = _libssh2_list_next(&chunk->node);
         }
+    }
 
-        /* fall-through */
-    case libssh2_NB_state_sent:
+    if(count >= acked) {
+        /* skip the part that's already sent but not yet acked to user */
+        buffer += acked;
+        count -= acked;
+    }
+    else
+        /* there is more data already fine than what we got in this call */
+        count = 0;
+
+    while(count) {
+        /* TODO: Possibly this should have some logic to prevent a very
+           very small fraction to be left but lets ignore that for now */
+        uint32_t size = MIN(MAX_SFTP_OUTGOING_SIZE, count);
+        uint32_t request_id;
+
+        /* 25 = packet_len(4) + packet_type(1) + request_id(4) +
+           handle_len(4) + offset(8) + count(4) */
+        packet_len = handle->handle_len + size + 25;
+
+        chunk = LIBSSH2_ALLOC(session, packet_len +
+                              sizeof(struct sftp_pipeline_chunk));
+        if(!chunk)
+            return _libssh2_error(session, LIBSSH2_ERROR_ALLOC,
+                                  "malloc fail for FXP_WRITE");
 
-        sftp->write_state = libssh2_NB_state_idle;
-        /*
-         * Count all ACKed packets
-         */
-        chunk = _libssh2_list_first(&handle->packet_list);
+        chunk->len = size;
+        chunk->sent = 0;
+        chunk->lefttosend = packet_len;
 
-        while(chunk) {
-            if(chunk->lefttosend)
-                /* if the chunk still has data left to send, we shouldn't wait
-                   for an ACK for it just yet */
-                break;
+        s = chunk->packet;
+        _libssh2_store_u32(&s, packet_len - 4);
 
-            else if(acked)
-                /* if we have sent data that is acked, we must return that
-                   info before we call a function that might return EAGAIN */
-                break;
+        *(s++) = SSH_FXP_WRITE;
+        request_id = sftp->request_id++;
+        chunk->request_id = request_id;
+        _libssh2_store_u32(&s, request_id);
+        _libssh2_store_str(&s, handle->handle, handle->handle_len);
+        _libssh2_store_u64(&s, handle->u.file.offset_sent);
+        handle->u.file.offset_sent += size; /* advance offset at once */
+        _libssh2_store_str(&s, buffer, size);
 
-            /* we check the packets in order */
-            rc = sftp_packet_require(sftp, SSH_FXP_STATUS,
-                                     chunk->request_id, &data, &data_len);
-            if(rc < 0) {
-                if(rc == LIBSSH2_ERROR_EAGAIN)
-                    sftp->write_state = libssh2_NB_state_sent;
-                return rc;
-            }
+        /* add this new entry LAST in the list */
+        _libssh2_list_add(&handle->packet_list, &chunk->node);
 
-            retcode = _libssh2_ntohu32(data + 5);
-            LIBSSH2_FREE(session, data);
+        buffer += size;
+        count -= size; /* deduct the size we used, as we might have
+                          to create more packets */
 
-            sftp->last_errno = retcode;
-            if(retcode == LIBSSH2_FX_OK) {
-                acked += chunk->len; /* number of payload data that was acked
-                                        here */
+        /* packet added to list, now send it off */
+        rc = _libssh2_channel_write(channel, 0,
+                                    &chunk->packet[chunk->sent],
+                                    chunk->lefttosend);
+        if(rc < 0)
+            /* remain in idle state */
+            return rc;
 
-                /* we increase the offset value for all acks */
-                handle->u.file.offset += chunk->len;
+        /* remember where to continue sending the next time */
+        chunk->lefttosend -= rc;
+        chunk->sent += rc;
 
-                next = _libssh2_list_next(&chunk->node);
+        if(chunk->lefttosend)
+            goto exit;
 
-                _libssh2_list_remove(&chunk->node); /* remove from list */
-                LIBSSH2_FREE(session, chunk); /* free memory */
+        acked += chunk->len;
+        handle->u.file.offset += chunk->len;
+    }
+    /*
+     * Sweep all ACKed packets; this can abort transfer, so don't do this
+     * in the middle of sending a packet
+     */
+    chunk = _libssh2_list_first(&handle->packet_list);
 
-                chunk = next;
-            }
-            else {
-                /* flush all pending packets from the outgoing list */
-                sftp_packetlist_flush(handle);
+    while(chunk) {
+        if(chunk->lefttosend)
+            /* if the chunk still has data left to send, we shouldn't wait
+               for an ACK for it just yet */
+            break;
 
-                /* since we return error now, the application will not get any
-                   outstanding data acked, so we need to rewind the offset to
-                   where the application knows it has reached with acked data */
-                handle->u.file.offset -= handle->u.file.acked;
+        /* we check the packets in order */
+        rc = sftp_packet_require(sftp, SSH_FXP_STATUS,
+                                 chunk->request_id, &data, &data_len);
+        if(rc < 0)
+            break;
 
-                /* then reset the offset_sent to be the same as the offset */
-                handle->u.file.offset_sent = handle->u.file.offset;
+        retcode = _libssh2_ntohu32(data + 5);
+        LIBSSH2_FREE(session, data);
 
-                /* clear the acked counter since we can have no pending data to
-                   ack after an error */
-                handle->u.file.acked = 0;
+        sftp->last_errno = retcode;
+        if(retcode == LIBSSH2_FX_OK) {
+            /* all good, just remove from pending list */
+            next = _libssh2_list_next(&chunk->node);
 
-                /* the server returned an error for that written chunk, propagate
-                   this back to our parent function */
-                return _libssh2_error(session, LIBSSH2_ERROR_SFTP_PROTOCOL,
-                                      "FXP write failed");
-            }
+            _libssh2_list_remove(&chunk->node); /* remove from list */
+            LIBSSH2_FREE(session, chunk); /* free memory */
+
+            chunk = next;
         }
-        break;
-    }
+        else {
+            /* flush all pending packets from the outgoing list */
+            sftp_packetlist_flush(handle);
+
+            /* since we return error now, the application will not get any
+               outstanding data acked, so we need to rewind the offset to
+               where the application knows it has reached with acked data */
+            handle->u.file.offset -= handle->u.file.acked;
 
-    /* if there were acked data in a previous call that wasn't returned then,
-       add that up and try to return it all now. This can happen if the app
-       first sends a huge buffer of data, and then in a second call it sends a
-       smaller one. */
-    acked += handle->u.file.acked;
+            /* then reset the offset_sent to be the same as the offset */
+            handle->u.file.offset_sent = handle->u.file.offset;
 
+            /* clear the acked counter since we can have no pending data to
+               ack after an error */
+            handle->u.file.acked = 0;
+
+            /* the server returned an error for that written chunk, propagate
+               this back to our parent function */
+            return _libssh2_error(session, LIBSSH2_ERROR_SFTP_PROTOCOL,
+                                  "FXP write failed");
+        }
+    }
+
+exit:
     if(acked) {
         ssize_t ret = MIN(acked, org_count);
-        /* we got data acked so return that amount, but no more than what
+        /* we got data sent so return that amount, but no more than what
            was asked to get sent! */
 
         /* store the remainder. 'ret' is always equal to or less than 'acked'
